<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Fantasy Ace's blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fantasynew.github.io/"/>
  <updated>2014-12-15T14:52:43.900Z</updated>
  <id>http://fantasynew.github.io/</id>
  
  <author>
    <name><![CDATA[Fantasy Ace]]></name>
    <email><![CDATA[jingjiewuying@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[嵌套监控锁定]]></title>
    <link href="http://fantasynew.github.io/2014/05/05/13.nested-monitor-lockout/"/>
    <id>http://fantasynew.github.io/2014/05/05/13.nested-monitor-lockout/</id>
    <published>2014-05-05T14:06:44.000Z</published>
    <updated>2014-05-27T13:08:02.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/nested-monitor-lockout.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/nested-monitor-lockout.html</a></p>
<h2 id="嵌套监控锁定如何产生">嵌套监控锁定如何产生</h2>
<p>　　嵌套监控锁定是类似于死锁的问题，嵌套监控锁定的产生就像这样：</p>
<blockquote>
<p>线程1获得A的锁<br>线程1获得B的锁(此时还持有A的锁)<br>线程1在继续之前要等待其它线程的信号<br>线程1调用B.wait()来释放B的锁，而不是A。</p>
<p>线程2需要锁住A和B(按照这个顺序)来给线程1发送它需要的信号。<br>线程2不能锁住A，因为线程1还在持有A上面的锁。<br>线程2会一直阻塞等待线程1释放A上面的锁</p>
<p>线程1会一直阻塞等待线程2的信号，因此不会释放A上面的锁，而这个锁必须被释放来保证线程2给线程1发送信号，等等。</p>
</blockquote>
<p>　　这听起来好像是一个纯理论上的情形，但是看看下面的比较幼稚的Lock实现：</p>
<blockquote>
<p><code>//lock implementation with nested monitor lockout problem</code>  </p>
<p><code>public class Lock{</code><br>　　<code>protected MonitorObject monitorObject = new MonitorObject();</code><br>　　<code>protected boolean isLocked = false;</code>  </p>
<p>　　<code>public void lock() throws InterruptedException{</code><br>　　　　<code>synchronized(this){</code><br>　　　　　　<code>while(isLocked){</code><br>　　　　　　　　<code>synchronized(this.monitorObject){</code><br>　　　　　　　　　　<code>this.monitorObject.wait();</code><br>　　　　　　　　<code>}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>isLocked = true;</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public void unlock(){</code><br>　　　　<code>synchronized(this){</code><br>　　　　　　<code>this.isLocked = false;</code><br>　　　　　　<code>synchronized(this.monitorObject){</code><br>　　　　　　　　<code>this.monitorObject.notify();</code><br>　　　　　　<code>}</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code></p>
</blockquote>
<p>　　可以看到<code>lock()</code>方法首先在”this”上面同步，然后在monitorObject成员变量上同步。如果isLocked 是false不会出现问题，线程不会调用<code>monitorObject.wait()</code>。但是如果isLocked 是true的话，调用<code>lock()</code>的线程会阻塞在<code>monitorObject.wait()</code>的调用上。</p>
<p>　　这里的问题是，<code>monitorObject.wait()</code>的调用只释放了monitorObject 对象的监控锁，而与”this”相关的监控锁没有被释放。换句话说，这个刚刚阻塞等待的线程还持有”this”的同步锁。</p>
<p>　　当一开始锁住Lock的线程尝试调用unlock()来解锁时，它会阻塞在中尝试进入unlock()方法中的<code>synchronized(this)</code>块上面。它会一直阻塞直到在lock()上面等待的线程离开<code>synchronized(this)</code>块。但是，在unlock()方法中isLocked被设置为false，并且<code>monitorObject.notify()</code>得到执行之后，在lock()方法里面等待的线程才会离开这个块。</p>
<p>　　简而言之，在lock()方法上面等待的线程需要unlock()调用成功执行来帮助它退出lock()方法和它里面的同步块。但是除非在lock()上面等待的线程离开外面的同步块，其它线程才能够成功执行unlock()方法。</p>
<p>　　这就导致任何调用lock()和unlock()方法的线程都会阻塞，这就是嵌套监控锁定。</p>
<h2 id="一个更加现实的例子">一个更加现实的例子</h2>
<p>　　你可能会说你永远都不会实现前面展示的锁。你或许不会在内部监控对象上面调用wait()和notify()方法，在这里可能是真的。但是还是会出现一些情况下会出现上面的设计。比如，如果你打算在一个Lock里面实现公平，做这些工作时你希望每个线程都在它们自己的队列对象上面调用wait()方法，这样就可以每次唤醒一个线程了。</p>
<p>　　看看这个公平锁的幼稚实现：</p>
<blockquote>
<p><code>//Fair Lock implementation with nested monitor lockout problem</code>  </p>
<p><code>public class FairLock {</code><br>　　<code>private boolean           isLocked       = false;</code><br>　　<code>private Thread            lockingThread  = null;</code><br>　　<code>private List&lt;QueueObjectwaitingThreads = new ArrayList&lt;QueueObject&gt;();</code></p>
<p>　　<code>public void lock() throws InterruptedException{</code><br>　　　　<code>QueueObject queueObject = new QueueObject();</code>  </p>
<p>　　　　<code>synchronized(this){</code><br>　　　　　　<code>waitingThreads.add(queueObject);</code>  </p>
<p>　　　　　　<code>while(isLocked || waitingThreads.get(0) != queueObject){</code>  </p>
<p>　　　　　　　　<code>synchronized(queueObject){</code><br>　　　　　　　　　　<code>try{</code><br>　　　　　　　　　　　　<code>queueObject.wait();</code><br>　　　　　　　　　　<code>}catch(InterruptedException e){</code><br>　　　　　　　　　　　　<code>waitingThreads.remove(queueObject);</code><br>　　　　　　　　　　　　<code>throw e;</code><br>　　　　　　　　　　<code>}</code><br>　　　　　　　　<code>}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>waitingThreads.remove(queueObject);</code><br>　　　　　　<code>isLocked = true;</code><br>　　　　　　<code>lockingThread = Thread.currentThread();</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void unlock(){</code><br>　　　　<code>if(this.lockingThread != Thread.currentThread()){</code><br>　　　　　　<code>throw new IllegalMonitorStateException(</code><br>　　　　　　　　<code>&quot;Calling thread has not locked this lock&quot;);</code><br>　　　　<code>}</code><br>　　　　<code>isLocked      = false;</code><br>　　　　<code>lockingThread = null;</code><br>　　　　<code>if(waitingThreads.size() 0){</code><br>　　　　　　<code>QueueObject queueObject = waitingThread.get(0);</code><br>　　　　　　<code>synchronized(queueObject){</code><br>　　　　　　　　<code>queueObject.notify();</code><br>　　　　　　<code>}</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
<p><code>public class QueueObject {}</code></p>
</blockquote>
<p>　　匆匆一看可能会觉得这个实现看起来不错，但是请注意lock()方法在两个嵌套同步块里面调用了queueObject.wait()。一个在”this”上面进行同步，嵌套在其内部的是在queueObject局部变量进行同步。当一个线程调用queueObject.wait()它会释放QueueObject实例上面的锁，但是不会释放与”this”相关的锁。</p>
<p>　　同时注意，unlock()方法被声明为synchronized，这就相当于加了一个synchronized(this)块。这意味着，如果一个线程在lock()里面等待，这个等待线程就会锁住与”this”相关的监控对象。所有调用unlock()的线程都会一直阻塞，等待这个等待线程释放”this”上面的锁。但是这种情况永远都不会发生了，因为这情况只发生在一个线程成功的给等待线程发送信号时，而这个信号只能通过执行unlock()方法来发送。</p>
<p>　　因此，上面这个公平锁实现会导致嵌套监控锁定，更好的公平锁实现在饥饿与公平一文中进行了介绍。</p>
<h2 id="嵌套监控锁定与死锁比较">嵌套监控锁定与死锁比较</h2>
<p>　　嵌套监控锁定与死锁导致的结果非常相似：线程都阻塞在互相等待上面了。</p>
<p>　　但是这两种情况还不太一样，死锁一文中讲过死锁发生在两个线程按照不同的顺序获得锁。线程1锁住A等待B，线程2锁住B等待A。在死锁预防一文中介绍过，死锁可以通过按照一定的顺序(锁顺序)给锁加锁来预防。然而，一个嵌套监控锁定恰恰发生在两个线程按照<strong>同样的顺序</strong>获得锁的时候。线程1锁住A和B，然后释放B并且等待线程2的信号。线程2需要A和B来给线程1发送信号。所以，一个线程等待信号而另一个线程等待一个锁被释放。</p>
<p>　　不同点归纳如下：</p>
<blockquote>
<p>在死锁中，两个线程互相等待对方释放锁。</p>
<p>在嵌套监控锁定中，线程1持有锁A并且等待线程2的信号。线程2需要锁A来给线程1发送信号。</p>
</blockquote>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="嵌套监控锁定" scheme="http://fantasynew.github.io/tags/%E5%B5%8C%E5%A5%97%E7%9B%91%E6%8E%A7%E9%94%81%E5%AE%9A/"/>
    
      <category term="死锁" scheme="http://fantasynew.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[饥饿与公平]]></title>
    <link href="http://fantasynew.github.io/2014/05/03/12.starvation-and-fairness/"/>
    <id>http://fantasynew.github.io/2014/05/03/12.starvation-and-fairness/</id>
    <published>2014-05-03T14:06:44.000Z</published>
    <updated>2014-05-23T13:42:33.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html</a></p>
<p>如果一个线程因为其它线程一直占用而没有获得CPU时间，就称为“饥饿”。线程被“饿死”是因为其它线程一直占用CPU时间而它没有。饥饿的解决方案被称作“公平”，所有的线程都被授予相同的执行机会。</p>
<h1 id="Java中引起饥饿的原因">Java中引起饥饿的原因</h1>
<p>下面是导致java线程饥饿的三个常见原因：</p>
<ol>
<li>高优先级的线程吞下了低优先级线程的所有CPU时间。</li>
<li>线程无限期的阻塞在等待进入一个同步块上面，因为其它线程不断的请求进入该同步块。</li>
<li>线程无限期的等待一个对象（调用了对象的wait()方法），因为其它线程不断的被唤醒。</li>
</ol>
<h2 id="高优先级的线程吞下了低优先级线程的所有CPU时间">高优先级的线程吞下了低优先级线程的所有CPU时间</h2>
<p>　　你可以为每个线程设置线程优先级，线程的优先级越高所获得的CPU时间越多。你可以设置线程的优先级在1到10之间，这些优先级数值所表示的含义跟你的应用程序所在的操作系统有关。对大多数应用程序来说最好保持其优先级不变。</p>
<h2 id="线程无限期的阻塞在等待进入一个同步块上面">线程无限期的阻塞在等待进入一个同步块上面</h2>
<p>　　java同步代码块是引起饥饿的另一个原因，java同步代码块不保证被允许进入的等待线程进入同步块的顺序。这意味着存在理论上的风险，一个线程被永远阻塞进入代码块，因为其它线程不断地在它之前获得授权，这就是“饥饿”问题，一个线程“饿死”的原因是其它线程不断的获取CPU时间。</p>
<h2 id="线程无限期的等待一个对象（调用了对象的wait()方法）">线程无限期的等待一个对象（调用了对象的wait()方法）</h2>
<p>　　notify()方法并不保证哪个线程会被唤醒如果多个线程调用了与它同属一个对象的wait()方法。任何线程都会被唤醒，所以就会出现一个线程因为其它等待线程不断被唤醒而永远等待一个特定对象的风险。</p>
<h1 id="在java中实现公平">在java中实现公平</h1>
<p>　　尽管在java中不能保证实现100%的公平，我们仍然可以通过同步结构在线程之间提高公平性。</p>
<p>　　首先学习下一个简单的同步代码块：</p>
<blockquote>
<p><code>public class Synchronizer{</code>  </p>
<p>　　<code>public synchronized void doSynchronized(){</code><br>　　　　<code>//do a lot of work which takes a long time</code><br>　　<code>}</code>  </p>
<p><code>}</code>  </p>
</blockquote>
<p>　　如果多个线程调用doSynchronized()方法，它们中的一些会被阻塞直到第一个线程获得授权并离开这个方法。如果多个线程阻塞等待访问代码，我们无法保证下一个获得授权的线程是哪个。</p>
<h2 id="使用锁代替同步块">使用锁代替同步块</h2>
<p>　　为了提高等待线程的公平性，首先我们修改代码块使用锁来代替同步块：</p>
<blockquote>
<p><code>public class Synchronizer{</code><br>　　<code>Lock lock = new Lock();</code>  </p>
<p>　　<code>public void doSynchronized() throws InterruptedException{</code><br>　　　　<code>this.lock.lock();</code><br>　　　　<code>//critical section, do a lot of work which takes a long time</code><br>　　　　<code>this.lock.unlock();</code><br>　　<code>}</code>  </p>
<p><code>}</code>  </p>
</blockquote>
<p>　　注意doSynchronized()上面不再加synchronized声明。相反，关键部分用lock.lock()和lock.unlock()来替代。</p>
<p>　　一个Lock类的简单实现应该像下面这样：</p>
<blockquote>
<p><code>public class Lock{</code><br>　　<code>private boolean isLocked      = false;</code><br>　　<code>private Thread  lockingThread = null;</code>  </p>
<p>　　<code>public synchronized void lock() throws InterruptedException{</code><br>　　　　<code>while(isLocked){</code><br>　　　　　　<code>wait();</code><br>　　　　<code>}</code><br>　　　　<code>isLocked      = true;</code><br>　　　　<code>lockingThread = Thread.currentThread();</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void unlock(){</code><br>　　　　<code>if(this.lockingThread != Thread.currentThread()){</code><br>　　　　　　<code>throw new IllegalMonitorStateException(</code><br>　　　　　　　　<code>&quot;Calling thread has not locked this lock&quot;);</code><br>　　　　　<code>}</code><br>　　　　　<code>isLocked      = false;</code><br>　　　　　<code>lockingThread = null;</code><br>　　　　　<code>notify();</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　如果你注意下上面的Synchronizer类和这个Lock实现你会发现，如果多个线程同时调用lock()方法，它们会阻塞在lock()方法访问上。另外如果锁被锁住了，线程会阻塞在while(isLocked)循环里面的wait()方法调用上。需要记住的是，一个线程调用wait()方法会释放掉Lock实例上面的同步锁，这样等待进入lock()的线程现在可以进入lock()方法了。结果是多个线程最后都会调用lock()方法里面的wait()方法。</p>
<p>　　如果你回顾一下doSynchronized()方法，你会看到lock()和unlock()方法之间的注释，说明了在这两个调用之间的代码会花费很长时间来执行。让我们来进一步假设这段代码的执行时间比进入lock()方法并因为锁被锁住了而调用wait()等待的时间要长很多。这意味着大部分的时间都花费在等待进入锁并进入临界区的lock()方法里面的wait()调用上面，而不是阻塞在尝试进入lock()方法上面。</p>
<p>　　前面说过如果有多个线程等待进入的情况下，同步块并不确定哪个线程会被授予访问权限。同样，当notify()方法被调用时，wait()方法也不保证哪个线程会被唤醒。所以，在保证同步性方面这个版本的Lock类与doSynchronized()的同步版本并没有什么不同。但是我们可以改变这种情况。</p>
<p>　　当前版本的Lcok类调用了自己的wait()方法，如果每个线程在单独的对象上面调用wait()方法，那样每个对象上面只有一个线程调用了wait()，Lock类就可以通过决定调用哪个对象上面的notify()方法，来有效地选择唤醒哪个线程。</p>
<h2 id="公平锁">公平锁</h2>
<p>　　下面演示了之前的Lock类改变成一个公平锁叫做FairLock。你会发现这个实现与之前的Lock类中的同步和wait()/noftify()稍有不同。</p>
<p>　　我如何从之前的Lock类来到现在这个FairLock类的设计涉及到了几个增量式步骤，之前每一步解决的问题：嵌套监控锁定，游离条件和信号丢失。为了不使本文过长这些讨论从本文去掉了，不过每一步都会在本系列下面的文章中进行介绍。重要的是现在每个调用lock()的线程都进行了排序，并且只有队列中第一个线程被允许锁住FairLock实例，如果它没被锁住的话。所有其它线程都只能等待直到它们到达队列的顶部。</p>
<blockquote>
<p><code>public class FairLock {</code><br>　　<code>private boolean          isLocked      = false;</code><br>　　<code>private Thread            lockingThread  = null;</code><br>　　<code>private List&lt;QueueObjectwaitingThreads = new ArrayList&lt;QueueObject&gt;();</code></p>
<p>　　<code>public void lock() throws InterruptedException{</code><br>　　　　<code>QueueObject queueObject          = new QueueObject();</code><br>　　　　<code>boolean    isLockedForThisThread = true;</code><br>　　　　<code>synchronized(this){</code><br>　　　　　　<code>waitingThreads.add(queueObject);</code><br>　　　　<code>}</code>  </p>
<p>　　　　<code>while(isLockedForThisThread){</code><br>　　　　　　<code>synchronized(this){</code><br>　　　　　　　　<code>isLockedForThisThread =</code><br>　　　　　　　　 　　<code>isLocked || waitingThreads.get(0) != queueObject;</code><br>　　　　　　　　<code>if(!isLockedForThisThread){</code><br>　　　　　　　　　　<code>isLocked = true;</code><br>　　　　　　　　　　<code>waitingThreads.remove(queueObject);</code><br>　　　　　　　　　　<code>lockingThread = Thread.currentThread();</code><br>　　　　　　　　　　<code>return;</code><br>　　　　　　　　<code>}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>try{</code><br>　　　　　　　　<code>queueObject.doWait();</code><br>　　　　　　<code>}catch(InterruptedException e){</code><br>　　　　　　　　<code>synchronized(this) { waitingThreads.remove(queueObject); }</code><br>　　　　　　　　<code>throw e;</code><br>　　　　　　<code>}</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void unlock(){</code><br>　　　　<code>if(this.lockingThread != Thread.currentThread()){</code><br>　　　　　　<code>throw new IllegalMonitorStateException(</code><br>　　　　　　　　<code>&quot;Calling thread has not locked this lock&quot;);</code><br>　　　　<code>}</code><br>　　　　<code>isLocked      = false;</code><br>　　　　<code>lockingThread = null;</code><br>　　　　<code>if(waitingThreads.size() 0){</code><br>　　　　　　<code>waitingThreads.get(0).doNotify();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code></p>
<p><code>public class QueueObject {</code>  </p>
<p>　　<code>private boolean isNotified = false;</code>  </p>
<p>　　<code>public synchronized void doWait() throws InterruptedException {</code><br>　　　　<code>while(!isNotified){</code><br>　　　　　　<code>this.wait();</code><br>　　　　<code>}</code><br>　　　　<code>this.isNotified = false;</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void doNotify() {</code><br>　　　　<code>this.isNotified = true;</code><br>　　　　<code>this.notify();</code><br>　　<code>}</code>  </p>
<p>　　<code>public boolean equals(Object o) {</code><br>　　　　<code>return this == o;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　首先你可能会注意到lock()方法不再声明synchronized，而是只把需要同步的代码放到synchronized代码块里面。</p>
<p>　　FairLock新创建了一个QueueObject 实例并用它来为调用lock()的线程排序。调用unlock()的线程会获取队列顶部的QueueObject 并且调用它的doNotify()方法来唤醒在该对象上面等待的线程。按照这种方法，每次只有一个等待线程被唤醒，而不是所有的等待线程，这部分决定了FairLock的公平性。</p>
<p>　　注意在相同的同步块中锁的状态依旧被检查和设置来防止游离条件的发生。</p>
<p>　　同时还要注意，QueueObject实际上只是一个信号，<code>doWait()</code>和<code>doNotify()</code>方法在<code>QueueObject</code>内部保存信号。这样做是为了防止线程调用<code>queueObject.doWait()</code>之前被另一个调用unlock()方法进而调用<code>queueObject.doNotify()</code>的线程打断而引起的信号丢失。<code>queueObject.doWait()</code>调用被放在 <code>synchronized(this)</code>块外面来避免嵌套监控锁定，这样没有线程在<code>lock()</code>方法里面的<code>synchronized(this)</code>里执行时其它线程就可以调用unclock()。</p>
<p>　　最后，注意<code>queueObject.doWait()</code>是在一个<code>try - catch</code>块里面被调用的。如果抛出了一个InterruptedException异常，线程会离开lock()方法，我们应该在队列里面把它去掉。</p>
<h2 id="性能考虑">性能考虑</h2>
<p>　　如果你比较一下<em>Lock</em>和<em>FairLock</em>类，你会发现<em>FairLock</em>类的lock()和unlock()里面的东西更多。这些多出来的代码会导致<em>FairLock</em>的同步机制比<em>Lock</em>有一点慢。这对你的应用程序的影响有多大取决于在<em>FairLock</em>创建的临界区里面的代码执行的时间有多长。执行的时间越长，同步器的额外开销越小。这当然也和这段代码被调用的频繁程度有关系。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="饥饿" scheme="http://fantasynew.github.io/tags/%E9%A5%A5%E9%A5%BF/"/>
    
      <category term="公平" scheme="http://fantasynew.github.io/tags/%E5%85%AC%E5%B9%B3/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[死锁预防]]></title>
    <link href="http://fantasynew.github.io/2014/05/02/11.deadlock-prevention/"/>
    <id>http://fantasynew.github.io/2014/05/02/11.deadlock-prevention/</id>
    <published>2014-05-02T14:06:44.000Z</published>
    <updated>2014-05-23T13:34:39.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html</a></p>
<p>在某些情况下预防死锁是可能的。在本文中我会介绍三个预防死锁的技术：</p>
<ol>
<li>Lock Ordering 加锁顺序</li>
<li>Lock Timeout 加锁时限</li>
<li>Deadlock Detection 死锁检测</li>
</ol>
<h2 id="加锁顺序">加锁顺序</h2>
<p>　　当多个线程需要相同的锁但是以不同的顺序获得它们的情况下，死锁很容易发生。</p>
<p>　　如果你能确保所有的线程都按照相同的顺序获得锁，死锁就不会发生。看下面的例子：</p>
<blockquote>
<p><code>Thread 1:</code>  </p>
<p><code>lock A</code><br><code>lock B</code>  </p>
<p><code>Thread 2:</code></p>
<p><code>wait for A</code><br><code>lock C (when A locked)</code>  </p>
<p><code>Thread 3:</code>  </p>
<p><code>wait for A</code><br><code>wait for B</code><br><code>wait for C</code>  </p>
</blockquote>
<p>　　如果一个线程，比如线程3需要多个锁，它必须按照明确的顺序获得它们。在获得前面的锁之前它不能获得序列后面的锁。</p>
<p>　　例如，在获得锁A之前线程2和3都不能获得锁C。因为线程1持有锁A，线程2和3必须等待知道锁A被释放。然后它们必须先成功获取锁A，然后才能尝试去获取锁B和C。</p>
<p>　　加锁顺序是一个简单但非常有效的死锁预防机制。但是，这种方式只适用在你事先知道所有可能会用到的锁的情况下，一般并非如此。</p>
<h2 id="加锁时限">加锁时限</h2>
<p>　　另一个死锁预防机制是在尝试加锁的时候设置一个时限，意味着一个在尝试获得锁的过程中，如果超过了设定时限线程就会放弃。如果一个线程在给定时限内没有成功获取所有必须的锁，它就会回退，释放调所有已获得的锁，等待一段随机时间之后重试。这段等待随机时间给了其它线程获取相同锁来达到获取所有锁的机会，这样保证了应用程序能够继续运行。</p>
<p>　　下面是两个线程尝试以不同顺序获取两个相同锁的例子，发生超时后回退并重试请求：</p>
<blockquote>
<p><code>Thread 1 locks A</code><br><code>Thread 2 locks B</code>  </p>
<p><code>Thread 1 attempts to lock B but is blocked</code><br><code>Thread 2 attempts to lock A but is blocked</code>  </p>
<p><code>Thread 1&#39;s lock attempt on B times out</code><br><code>Thread 1 backs up and releases A as well</code><br><code>Thread 1 waits randomly (e.g. 257 millis) before retrying.</code>  </p>
<p><code>Thread 2&#39;s lock attempt on A times out</code><br><code>Thread 2 backs up and releases B as well</code><br><code>Thread 2 waits randomly (e.g. 43 millis) before retrying.</code>  </p>
</blockquote>
<p>　　在上面的例子中线程2比线程1早200毫秒来请求锁并因此成功的获得两个锁。这时线程1会尝试获取锁A并进入等待状态。当线程2结束时，线程1也可以获得两个锁（除非线程2或者其它线程又获得了锁）。</p>
<p>　　需要记住的是，因为存在锁的超时， 我们不能认为线程进入死锁状态。也可能是由于控制着锁（导致其它线程超时）的线程需要很长时间来完成自己的任务。</p>
<p>　　另外，如果有足够多的线程竞争相同的资源，就算有超时和回退机制，还是有一些线程同时一次又一次的尝试请求这些资源的风险。如果只有两个线程，并且重新尝试请求的间隔在0到500毫秒，这种情况可能不会发生，但是如果有10个或者20个线程时情况就不同了。因为这种情况下两个线程碰巧等待相同的时间来重试（或者非常接近以至于出现问题）的概率就特别高了。</p>
<p>　　加锁时限机制的问题是在java同步块中不能设置超时时间。你需要创建一个自定义锁类或者使用java 5中java.util.concurrency里面的并发结构。写一个自定义锁类并不能难，不过这不在本文讨论范围之内。java并发系列的后面文章会覆盖自定义锁。</p>
<h2 id="死锁检测">死锁检测</h2>
<p>　　死锁检测是一个重要的死锁预防机制主要用来解决按顺序加锁和加锁时限不能解决的问题。</p>
<p>　　每当线程<strong>获得</strong>锁时它会在线程和锁的数据结构(map，graph等等)里记下来。此外，当线程<strong>请求</strong>锁时也会在数据结构里记下来。</p>
<p>　　当一个线程请求一个锁但是请求被拒绝，这个线程可以遍历锁的关系图来检查是否发生了死锁。举个例子，如果线程A请求锁7但是锁7被线程B持有，那么线程A可以检查看线程B是否在请求线程A持有的一些锁。如果线程B在请求A持有的锁，就会发生死锁(线程A获得了锁1请求锁7，而线程B获得了锁7请求锁1)。</p>
<p>　　当然死锁场景可能比两个线程持有对方需要的锁的情况更加复杂。线程A可能等待线程B，线程B等待线程C，线程C等待线程D，线程D等待线程A。为了让线程A检查是否出现了死锁，必须递归检查线程B请求的所有锁。从线程B请求的锁，线程A会找到线程C，然后找到线程D，然后发现线程D在请求线程A持有的锁。这样线程A就知道出现了死锁。</p>
<p>　　下面是被四个线程(A、B、C、D)持有和请求锁的图。这样的数据接口可以被用来检查死锁。</p>
<p>　　　　　　　　　　　　　　　　<img src="http://fantasyace-photo.qiniudn.com/blog/img-blog002-deadlock-detection-graph.png" alt="mahua"></p>
<p>　　那么线程检查到死锁时会怎么做呢？</p>
<p>　　一个可能的行为是释放所有锁，回退，等待一个随机时间之后重试。这类似于简单的锁超时机制，不一样的是线程在明确知道死锁发生时才进行回退操作，而不仅仅因为自己的锁请求超时了。然而，如果有大量的线程竞争同一个锁即使回退并等待它们还是会重复发生死锁。</p>
<p>　　一个更好的方案是给线程确定并分配一个优先级，这样只有一个(或者一些)线程回退，其它线程继续持有自己需要的锁并像没发生死锁似的继续运行。如果分给线程的优先级是固定的，同一批线程总是会被给更高的优先级。为了防止这种情况你应该在发生死锁时随机分配优先级。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁预防" scheme="http://fantasynew.github.io/tags/%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2/"/>
    
      <category term="Timeout" scheme="http://fantasynew.github.io/tags/Timeout/"/>
    
      <category term="Detection" scheme="http://fantasynew.github.io/tags/Detection/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[死锁]]></title>
    <link href="http://fantasynew.github.io/2014/05/01/10.deadlock/"/>
    <id>http://fantasynew.github.io/2014/05/01/10.deadlock/</id>
    <published>2014-05-01T14:06:44.000Z</published>
    <updated>2014-05-15T14:08:02.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/deadlock.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/deadlock.html</a></p>
<h2 id="线程死锁">线程死锁</h2>
<p>　　死锁是两个或多个线程阻塞的等待获取其它死锁线程拥有的锁。死锁发生在多个线程同时但以不同顺序获取请求同一组锁的情况下。</p>
<p>　　比如，如果线程1锁住了A并且尝试锁住B，而线程2已经锁住B并且尝试锁住A，就会出现死锁。线程1永远也得不到B，线程2永远也得不到A。并且，它们谁都不知道发生了这种意外。它们会一直阻塞在自己对象上A和B，这种情况就是死锁。</p>
<p>　　情况说明如下：</p>
<blockquote>
<p><code>Thread 1  locks A, waits for B</code><br><code>Thread 2  locks B, waits for A</code></p>
</blockquote>
<p>　　下面是一个在不同实例上面调用同步方法的TreeNode类的例子：</p>
<blockquote>
<p><code>public class TreeNode {</code></p>
<p>　　<code>TreeNode parent   = null;</code><br>　　<code>List children = new ArrayList();</code>  </p>
<p>　　<code>public synchronized void addChild(TreeNode child){</code><br>　　　　<code>if(!this.children.contains(child)) {</code><br>　　　　　　<code>this.children.add(child);</code><br>　　　　　　<code>child.setParentOnly(this);</code><br>　　　　<code>}</code><br>　　<code>}</code></p>
<p>　　<code>public synchronized void addChildOnly(TreeNode child){</code><br>　　　　<code>if(!this.children.contains(child){</code><br>　　　　　　<code>this.children.add(child);</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void setParent(TreeNode parent){</code><br>　　　　<code>this.parent = parent;</code><br>　　　　<code>parent.addChildOnly(this);</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void setParentOnly(TreeNode parent){</code><br>　　　　<code>this.parent = parent;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　如果在同一个parent和child实例上面，线程1调用parent.addChild(child)方法的同时另一个线程2调用child.setParent(parent)方法，就会出现死锁。下面的伪代码演示了这一点：</p>
<blockquote>
<p><code>Thread 1: parent.addChild(child); //locks parent</code><br>　　　　　<code>--child.setParentOnly(parent);</code></p>
<p><code>Thread 2: child.setParent(parent); //locks child</code><br>　　　　　<code>--parent.addChildOnly()</code></p>
</blockquote>
<p>　　首先线程1调用parent.addChild(child)，因为addChild()是同步的线程1就锁住了parent对象防止其它线程使用。</p>
<p>　　然后线程2调用child.setParent(parent)，因为setParent()是同步的线程2就锁住了child对象防止其它线程使用。</p>
<p>　　现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是child对象被线程2锁住了，所以调用方法被阻塞了。线程2也尝试调用parent.addChildOnly()但是parent对象被线程1锁住了，导致线程2阻塞在方法调用上。现在两个线程都被阻塞等待获取另一个线程持有的锁。</p>
<p>　　注意：这两个线程必须像上面描述的那样同时并且在同一个parent 和child实例中调用parent.addChild(child)和child.setParent(parent)方法才能出现死锁情况。上面的代码可能在很长一段时间内正常执行直到突然发生死锁。</p>
<p>　　这些线程需要<strong>同时</strong>获得锁。比如，如果线程1比线程2稍微提前一点，然后锁住了A和B两个对象，那么线程2在尝试锁住B的时候就阻塞了，也就不会出现死锁了。既然线程调度通常都是不可预测的，所以没有办法预知<strong>何时</strong>会产生死锁，我们只知道它<strong>可能会</strong>出现。</p>
<h2 id="更复杂的死锁">更复杂的死锁</h2>
<p>　　死锁还可以包含超过两个线程，这让它更难被检测出来。下面是四个线程死锁的例子：  </p>
<blockquote>
<p><code>Thread 1  locks A, waits for B</code><br><code>Thread 2  locks B, waits for C</code><br><code>Thread 3  locks C, waits for D</code><br><code>Thread 4  locks D, waits for A</code>  </p>
</blockquote>
<p>　　线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>
<h2 id="数据库死锁">数据库死锁</h2>
<p>　　更加复杂的死锁场景是在数据库事务处理中。一个数据库事务处理可能由多条SQL更新请求组成。当一条记录在事务中被更新时，这条事务就会被锁住防止其它事务更新，直到第一个事务完成。同一事务中的每次更新请求都会锁住一些数据库中的记录。</p>
<p>　　当多个事务同时需要对相同的记录做更新操作时，就会有出现死锁的风险。比如：</p>
<blockquote>
<p><code>Transaction 1, request 1, locks record 1 for update</code><br><code>Transaction 2, request 1, locks record 2 for update</code><br><code>Transaction 1, request 2, tries to lock record 2 for update.</code><br><code>Transaction 2, request 2, tries to lock record 1 for update.</code>  </p>
</blockquote>
<p>　　既然锁发生在不同的请求中，而且给定事务一开始并不知道自己需要哪些锁，所以很难发现并预防数据库事务出现死锁。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="http://fantasynew.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程通信]]></title>
    <link href="http://fantasynew.github.io/2014/04/29/09.thread-signaling/"/>
    <id>http://fantasynew.github.io/2014/04/29/09.thread-signaling/</id>
    <published>2014-04-29T14:06:44.000Z</published>
    <updated>2014-05-15T14:04:48.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/thread-signaling.html</a></p>
<p>　　线程通信的目的是让线程之间互相发送信号，另外线程通信可以使线程等待其它线程的信号。例如，线程B可以等待线程A的信号来表明待处理的数据已经准备好了。
　　</p>
<h2 id="通过共享对象通信">通过共享对象通信</h2>
<p>　　线程之间传递信号的简单方式是在一些共享对象变量里面设置信号值。线程A 可以在共享块里面设置boolean成员变量hasDataToProcess 为true，而线程B也可以在共享块里面读取hasDataToProcess成员变量的值。下面这个简单例子实现了一个持有这种信号的对象，并提供了方法来设置和查看方法：</p>
<blockquote>
<p><code>public class MySignal{</code>  </p>
<p>　　<code>protected boolean hasDataToProcess = false;</code>  </p>
<p>　　<code>public synchronized boolean hasDataToProcess(){</code><br>　　　　<code>return this.hasDataToProcess;</code><br>　　<code>}</code>  </p>
<p>　　<code>public synchronized void setHasDataToProcess(boolean hasData){</code><br>　　　　<code>this.hasDataToProcess = hasData;</code><br>　　<code>}</code>  </p>
<p><code>}</code>  </p>
</blockquote>
<p>　　线程A和B必须引用同一个共享的MySignal 实例来保证进行通信。如果线程A和B引用了不同的MySignal实例，它们就不会发现其它线程的信号。要处理的数据可能位于与MySignal实例分开存放的共享缓存区中。</p>
<h2 id="忙等待">忙等待</h2>
<p>　　准备处理数据的线程B等待数据变为可用，换句话说，它在等待线程A引起hasDataToProcess()返回true的信号。下面是线程B等待信号时运行在一个循环里面：  </p>
<blockquote>
<p><code>protected MySignal sharedSignal = ...</code>  </p>
<p><code>...</code>  </p>
<p><code>while(!sharedSignal.hasDataToProcess()){</code><br>　　<code>//do nothing... busy waiting</code><br><code>}</code>   </p>
</blockquote>
<p>　　注意while循环一直保持执行直到hasDataToProcess()返回true，这被称作忙等待，线程在等待的时候不是空闲的。
　　</p>
<h2 id="wait(),_notify()和notifyAll()">wait(), notify()和notifyAll()</h2>
<p>　　忙等待没有有效利用执行等待线程的计算机CPU，除非平均等待时间非常小。否则，如果等待线程可以进入睡眠状态或者非运行状态直到它得到一直在等待的信号更明智。</p>
<p>　　java有一个内建的等待机制来允许线程等待信号时变成非运行状态。java.lang.Object类定义了三个方法 wait(), notify()和notifyAll()来实现这个机制。</p>
<p>　　一个线程调用任何对象上面的wait()方法就会变成非运行状态，直到另一个线程调用同一对象的notify()方法。为了调用wait()或者notify()方法线程首先必须获得那个对象的锁。换句话说，线程必须在同步块里面调用wait()或者notify()方法。这是MySignal的修改版本——使用wait()和notify()方法的MyWaitNotify。</p>
<blockquote>
<p><code>public class MonitorObject{</code><br><code>}</code>  </p>
<p><code>public class MyWaitNotify{</code>  </p>
<p>　　<code>MonitorObject myMonitorObject = new MonitorObject();</code>  </p>
<p>　　<code>public void doWait(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>try{</code><br>　　　　　　　　<code>myMonitorObject.wait();</code><br>　　　　　　<code>} catch(InterruptedException e){...}</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public void doNotify(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>myMonitorObject.notify();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>   </p>
</blockquote>
<p>　　等待线程会调用doWait()方法，唤醒线程会调用doNotify()方法。当一个线程调用一个对象的notify()方法，这个对象上面等待的一个线程会被唤醒并且允许执行，还有一个notifyAll()方法用来唤醒所给对象的所有线程。</p>
<p>　　正如你所看到的那样，不管是等待线程还是唤醒线程都在同步块里面调用wait()和notify()方法。这是强制性的！一个线程如果没有持有被调方法所属对象的锁就不能调用其wait()、notify()和notifyAll()方法。否则，会抛出IllegalMonitorStateException异常。</p>
<p>　　但是，这怎么可能？等待线程在同步块里面执行的时候不少一直持有监控对象(myMonitorObject)的锁吗？等待线程不会阻塞唤醒线程进入到doNotify()的同步方法吗？答案是不。一旦一个线程调用了wait()方法它就和释放它持有监控对象的锁。这就允许其他线程来调用wait()和notify()方法，既然这些方法必须从共享块里面调用。</p>
<p>　　一个线程被唤醒之后不能退出wait()方法调用，直到这个线程调用notify()并且退出它的同步块。换句话说：被唤醒的线程在能退出wait()方法调用之前必须重新获得监控对象的锁，因为wait调用被嵌套在同步块里面。如果使用notifyAll()方法唤醒多个线程，每次只有一个被唤醒的线程能够能够退出wait()方法，因为每个线程在退出wait()方法之前必须获得监控对象的锁。</p>
<h2 id="丢失的信号(Missed_Signals)">丢失的信号(Missed Signals)</h2>
<p>　　notify()和notifyAll()不会保存调用它们的方法，以防当它们被调用时没有线程在等待状态。这样通知信号就会丢失。所以如果一个线程在调用wait()方法之前调用了notify()方法，等待线程就会丢失信号。这可能是也可能不是个问题，但是在某些情况下这可能导致等待线程永远等待下去，永远不会被激活，因为唤醒它的信号丢失了。</p>
<p>　　为避免信号丢失，必须把它们保存在信号类里。在MyWaitNotify示例里唤醒信号被保存在MyWaitNotify实例的成员变量里。下面是MyWaitNotify的修改版本：</p>
<blockquote>
<p><code>public class MyWaitNotify2{</code>  </p>
<p>　　<code>MonitorObject myMonitorObject = new MonitorObject();</code><br>　　<code>boolean wasSignalled = false;</code>  </p>
<p>　　<code>public void doWait(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>if(!wasSignalled){</code><br>　　　　　　　　<code>try{</code><br>　　　　　　　　　　<code>myMonitorObject.wait();</code><br>　　　　　　　　<code>} catch(InterruptedException e){...}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>//clear signal and continue running.</code><br>　　　　　　<code>wasSignalled = false;</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public void doNotify(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>wasSignalled = true;</code><br>　　　　　　<code>myMonitorObject.notify();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意doNotify()方法现在调用notify()方法之前先设置wasSignalled变量为true。同时，注意doWait()方法现在在调用wait()方法之前要先检查wasSignalled变量。实际上如果在上一个doWait()方法调用和当前的doWait()方法调用之间没有收到信号就会只调用wait()方法。</p>
<h2 id="假唤醒(Spurious_Wakeups)">假唤醒(Spurious Wakeups)</h2>
<p>　　由于一些匪夷所思的原因有时候可能出现一些线程在notify()和notifyAll()没被调用的情况下就被唤醒。这就是所谓的假唤醒，无缘无故的被唤醒。</p>
<p>　　如果MyWaitNofity2类的doWait()方法出现了假唤醒，即使没有收到适当信号等待线程也可能继续执行！这可能在你的应用程序中引起严重问题。</p>
<p>　　为了预防假唤醒的出现，在while循环里面检查信号成员变量而不是if语句中。这样的一个while循环也称作自旋锁。被唤醒的线程会自旋直到自旋锁(while循环)里面的条件变为false。下面是修改版的MyWaitNotify2示例来展示这段代码:</p>
<blockquote>
<p><code>public class MyWaitNotify3{</code></p>
<p>　　<code>MonitorObject myMonitorObject = new MonitorObject();</code><br>　　<code>boolean wasSignalled = false;</code>  </p>
<p>　　<code>public void doWait(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>while(!wasSignalled){</code><br>　　　　　　　　<code>try{</code><br>　　　　　　　　　　<code>myMonitorObject.wait();</code><br>　　　　　　　　<code>} catch(InterruptedException e){...}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>//clear signal and continue running.</code><br>　　　　　　<code>wasSignalled = false;</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public void doNotify(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>wasSignalled = true;</code><br>　　　　　　<code>myMonitorObject.notify();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意wait()方法的调用现在放在while循环里面而不是if语句中。如果等待线程还没有收到信号就被唤醒，wasSignalled成员会一直为false，这样while循环就会再次执行使被唤醒的线程回到等待状态。</p>
<h2 id="多个线程等待相同的信号">多个线程等待相同的信号</h2>
<p>　　如果你有多个线程在等待并且被notifyAll()唤醒，但是只有其中一个被允许执行 的情况下，while循环也是一个不错的解决方式。每次只有一个线程可以获得监控对象的锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志(把wasSignalled设为false)。一旦这个线程退出doWait()方法的同步块，其他线程才能退出wait()调用并在while循环里检查wasSignalled成员变量。但是，这个标志已经被第一个被唤醒的线程清除了，所以其余被唤醒线程只能回到等待状态直到下一个信号到来。</p>
<h2 id="不要在字符串常量或全局对象中调用wait()">不要在字符串常量或全局对象中调用wait()</h2>
<p>　　本文早期版本有一个使用字符串常量(“”)作为监控对象的MyWaitNotify示例类。下面是这个示例的代码：</p>
<blockquote>
<p><code>public class MyWaitNotify{</code>  </p>
<p>　　<code>String myMonitorObject = &quot;&quot;;</code><br>　　<code>boolean wasSignalled = false;</code>  </p>
<p>　　<code>public void doWait(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>while(!wasSignalled){</code><br>　　　　　　　　<code>try{</code><br>　　　　　　　　　　<code>myMonitorObject.wait();</code><br>　　　　　　　　<code>} catch(InterruptedException e){...}</code><br>　　　　　　<code>}</code><br>　　　　　　<code>//clear signal and continue running.</code><br>　　　　　　<code>wasSignalled = false;</code><br>　　　　<code>}</code><br>　　<code>}</code>  </p>
<p>　　<code>public void doNotify(){</code><br>　　　　<code>synchronized(myMonitorObject){</code><br>　　　　　　<code>wasSignalled = true;</code><br>　　　　　　<code>myMonitorObject.notify();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　在空字符串或者其他字符串常量上面调用wait()和notify()方法产生的问题是，JVM或编译器内部将字符串常量转化为同一个对象。这意味着即使你有两个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。也就意味着在第一个MyWaitNotify实例上面调用doWait()的线程有可能被第二个MyWaitNotify实例的doNotify()调用唤醒。</p>
<p>　　这种情况概述在下面的图示中：</p>
<p><img src="http://fantasyace-photo.qiniudn.com/blog/img-blog001.png" alt=""></p>
<p>　　注意，即使4个线程在同一个共享字符串实例上调用wait()和notify()方法，来自doWait()和doNotify()调用的信号都单独存储在两个MyWaitNotify实例中。MyWaitNotify 1上的doNotify()调用可能唤醒在MyWaitNotify 2上面等待的线程，但是这个信号只存储在MyWaitNotify 1上面。</p>
<p>　　开始这似乎不是一个大问题。毕竟，如果doNotify()在第二个MyWaitNotify实例上面被调用真正发生的也不过是线程A和B被错误的唤起。这个被唤起的线程(A或者B)会在while循环里检查信号，并且回到等待状态因为doNotify()方法没有在它们等待的第一个MyWaitNotify实例中被调用。这情况相当于激起了一个假唤醒，线程A或B在没有得到信号的情况下被唤醒。但是代码可以处理这个情况，所以线程回到等待状态。</p>
<p>　　问题在于，因为doNotify()调用只调用了notify()方法而不是notifyAll()，即使有4个线程在等待同一个字符串实例(空字符串)但是只有一个线程被唤醒。所以如果A和B线程中的一个被唤醒而信号只是用来唤醒C或D的，被唤醒的线程(A或B)会检查信号，看到没有接受到信号，然后回到等待状态。而C和D都没被唤醒来检查它们实际收到的信号，所以信号丢失了。这种情况相当于前面所述的信号丢失问题，C和D接到了一个信号但是不能对其作出回应。</p>
<p>　　如果doNotify()方法调用notifyAll()而不是notify()，所有的等待线程都被唤醒并且按顺序检查信号。线程A和B会回到等待状态，但是C和D中的一个会注意到这个信号并且离开doWait()方法调用。C和D中的另一个会回到等待状态因为发现信号的线程在退出doWait()方法时清除了信号。</p>
<p>　　然后你可能会想法使用notifyAll()来代替notify()，但是这在性能考虑上面却是个坏主意。当只有一个线程可以响应信号的时候没有理由把所有等待线程都唤醒。</p>
<p>　　所以：在wait()/notify()机制中不要使用全局对象、字符串常量等等，应该使用构造函数独特的唯一对象。例如，每一个MyWaitNotify3 (前面部分的例子) 实例都用自己的MonitorObject实例而不是用空字符串来调用wait()和notify()方法。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="http://fantasynew.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java同步块]]></title>
    <link href="http://fantasynew.github.io/2014/04/25/08.java-synchronized-blocks/"/>
    <id>http://fantasynew.github.io/2014/04/25/08.java-synchronized-blocks/</id>
    <published>2014-04-25T14:06:44.000Z</published>
    <updated>2014-05-14T14:33:14.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/synchronized.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/synchronized.html</a></p>
<p>　　Java同步块（Java synchronized block）标记一个方法或者代码块是同步的，Java同步块可被用来阻止竞态条件。</p>
<h2 id="Java_synchronized关键词">Java synchronized关键词</h2>
<p>　　java里面的同步块用<em>synchronized</em>关键词，一个java中的同步块在一些对象中是同步的。所有的同步在一个对象上面的同步块同时只能有一个线程在它里面执行。所有其它试图进入同步块的线程都会阻塞，直到同步块里面的线程退出这个块。  </p>
<p>　　<em>synchronized</em>关键词可以被用来标记四种不同类型的块：  </p>
<blockquote>
<p>1.实例方法<br>2.静态方法<br>3.实例方法内部的代码块<br>4.静态方法内部的代码块  </p>
</blockquote>
<p>　　这些块都可以在不同的对象中同步，你需要哪种类型的同步块取决于具体情况。  </p>
<h2 id="实例方法的同步">实例方法的同步</h2>
<p>　　下面是一个同步的实例方法：  </p>
<blockquote>
<p><code>public synchronized void add(int value){</code><br>　　<code>this.count += value;</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意方法声明里面使用了<em>synchronized</em>关键词，这个告诉java这个方法是同步的。  </p>
<p>　　在java中一个同步的实例方法在拥有这个方法的实例(对象)中是同步的。这样，每个实例（即该方法所属的实例）自己的同步方法在不同的对象上面是同步的。只有一个线程可以在同步的实例方法内部运。如果有多个实例存在的话，那么一个线程每次可以在一个实例的同步实例方法执行，一个实例一个线程。</p>
<h2 id="静态方法的同步">静态方法的同步</h2>
<p>　　静态方法的同步与实例方法一样使用<em>synchronized</em>关键字。下面是java静态方法同步例子：  
　　</p>
<blockquote>
<p><code>public static synchronized void add(int value){</code><br>　　<code>count += value;</code><br><code>}</code>  </p>
</blockquote>
<p>　　同样，这里的synchronized关键字告诉java这个方法是同步的。</p>
<p>　　同步的静态方法是同步在这个静态方法所属类的类对象上面。因为在java虚拟机中每个类只有一个类对象，所以在一个类中只有一个线程可以在其静态同步方法里面执行。</p>
<p>　　如果静态同步方法位于不同的类中，一个线程可以在每个类的静态同步方法中执行。不管它调用哪个静态同步方法一个线程只能负责一个类。
　　</p>
<h2 id="实例方法中的同步块">实例方法中的同步块</h2>
<p>　　不用同步整个方法，有时候只同步方法中一部分会更好，java方法中的同步块提供了这种可能性。</p>
<p>　　下面是一段在非同步的方法里面的java同步块代码：</p>
<blockquote>
<p><code>public void add(int value){</code><br>　　<code>synchronized(this){</code><br>　　　　<code>this.count += value;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　这个例子使用java同步块的构造标记一个代码块是同步的，这段代码执行时就和同步方法一样。</p>
<p>　　注意java同步块构造器用括号把对象包起来。这个例子中使用了”this”代表调用这个add方法的实例。被同步构造器包含到括号里面的对象被称作监控对象。这段代码表明监控对象应该同步，同步实例方法使用它所属的对象作为监控对象。</p>
<p>　　每次只有一个线程能在同步同一个监控对象的java代码块中执行。</p>
<p>　　下面的两个例子都同步在它们被调用的实例上面，它们的同步执行效果是相等的：</p>
<blockquote>
<p><code>public class MyClass {</code>  </p>
<p>　　<code>public synchronized void log1(String msg1, String msg2){</code><br>　　　　<code>log.writeln(msg1);</code><br>　　　　<code>log.writeln(msg2);</code><br>　　<code>}</code>  </p>
<p>　　<code>public void log2(String msg1, String msg2){</code><br>　　　　<code>synchronized(this){</code><br>　　　　　　<code>log.writeln(msg1);</code><br>　　　　　　<code>log.writeln(msg2);</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　在这个示例中每次只有一个线程能够在这两个同步块中的一个里面执行。</p>
<p>　　如果第二个同步块同步在另一个对象上而不是this，那么一个线程就可以同时在两个方法中执行。</p>
<h2 id="静态方法中的同步块">静态方法中的同步块</h2>
<p>　　下面是两个一样的静态方法例子，这两个方法都同步在它们所属的类对象上面：</p>
<blockquote>
<p><code>public class MyClass {</code>  </p>
<p>　　<code>public static synchronized void log1(String msg1, String msg2){</code><br>　　　　<code>log.writeln(msg1);</code><br>　　　　<code>log.writeln(msg2);</code><br>　　<code>}</code>  </p>
<p>　　<code>public static void log2(String msg1, String msg2){</code><br>　　　　<code>synchronized(MyClass.class){</code><br>　　　　　　<code>log.writeln(msg1);</code><br>　　　　　　<code>log.writeln(msg2);</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　一次只有一个线程可以在这两个方法内部执行。</p>
<p>　　如果第二个同步方法块被同步在MyClass.class之外的其他对象上面，那么一个线程可以同时在这两个方法里面执行。</p>
<h2 id="java同步例子">java同步例子</h2>
<p>　　下面是开启了两个线程并且让它们都调用同一个Counter实例的add方法，每次只有一个线程可以调用同一实例的add方法，因为方法在它所属的实例上面是同步的。</p>
<blockquote>
<p><code>public class Counter{</code>  </p>
<p>　　<code>long count = 0;</code>  </p>
<p>　　<code>public synchronized void add(long value){</code><br>　　　　<code>this.count += value;</code><br>　　<code>}</code><br><code>}</code>  </p>
<p><code>public class CounterThread extends Thread{</code>  </p>
<p>　　<code>protected Counter counter = null;</code>  </p>
<p>　　<code>public CounterThread(Counter counter){</code><br>　　　　<code>this.counter = counter;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void run() {</code><br>　　　　<code>for(int i=0; i&lt;10; i++){</code><br>　　　　　　<code>counter.add(i);</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code>  </p>
<p><code>public class Example {</code>  </p>
<p>　　<code>public static void main(String[] args){</code><br>　　　　<code>Counter counter = new Counter();</code><br>　　　　<code>Thread  threadA = new CounterThread(counter);</code><br>　　　　<code>Thread  threadB = new CounterThread(counter);</code>  </p>
<p>　　　　<code>threadA.start();</code><br>　　　　<code>threadB.start();</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　创建两个线程，并且把同一个Counter实例通过它们的构造函数传递给它们。Counter.add()方法在实例上是同步的，因为add方法是被标记为synchronized的实例方法。因此每次只有一个线程可以调用add()方法，另外一个线程在自己执行这个方法之前只能等待第一个线程退出add()方法。</p>
<p>　　如果两个线程引用的是两个不相关的Counter实例，同时调用add()方法就不会出现问题。这些方法调用了不同的对象，所以它们在不同的对象上(拥有方法的对象)也是同步的，所以调用不会被锁住。下面是示例：</p>
<blockquote>
<p><code>public class Example {</code>  </p>
<p>　　<code>public static void main(String[] args){</code><br>　　　　<code>Counter counterA = new Counter();</code><br>　　　　<code>Counter counterB = new Counter();</code><br>　　　　<code>Thread  threadA = new CounterThread(counterA);</code><br>　　　　<code>Thread  threadB = new CounterThread(counterB);</code>  </p>
<p>　　　　<code>threadA.start();</code><br>　　　　<code>threadB.start();</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意这两个线程threadA和threadB不再引用同一个Counter实例，counterA和counterB的add方法都同步在自己所属的实例上面。对counterA的add()方法的调用不会锁住对counterB的add()方法的调用。</p>
<h2 id="java并发工具">java并发工具</h2>
<p>　　同步机制是java第一个被多个线程共享访问的对象的同步机制，同步机制还不是很先进，所以java 5提供了一整套<a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank">并发工具类</a>来帮助开发者实现比你用synchronized方法得到的更细化的同步控制。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步块" scheme="http://fantasynew.github.io/tags/%E5%90%8C%E6%AD%A5%E5%9D%97/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程安全和不可变性]]></title>
    <link href="http://fantasynew.github.io/2014/04/21/07.thread-safety-and-immutability/"/>
    <id>http://fantasynew.github.io/2014/04/21/07.thread-safety-and-immutability/</id>
    <published>2014-04-21T14:06:44.000Z</published>
    <updated>2014-05-04T14:40:01.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html</a></p>
<p>　　只有当多个线程访问相同的资源，并且它们中的一个或多个线程对资源进行写操作时才会出现竞态条件。多个线程读取相同的资源时竞态条件不会出现。</p>
<p>　　我们可以通过创建不可变的共享对象来确保线程之间分享的对象不会被其它线程更新，以确保线程安全。例子如下：</p>
<blockquote>
<p><code>public class ImmutableValue{</code>  </p>
<p>　　<code>private int value = 0;</code>  </p>
<p>　　<code>public ImmutableValue(int value){</code><br>　　　　<code>this.value = value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public int getValue(){</code><br>　　　　<code>return this.value;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意ImmutableValue实例的value属性是在构造函数中赋值的，并且里面没有setter方法。一旦ImmutableValue实例被创建就不能改变它的value值，它是不可变的。不过，你可以使用 getValue()方法读取它的value值。</p>
<p>　　如果你需要对ImmutableValue实例执行操作，可以通过返回一个带有操作结果的新实例来实现。下面是一个加法操作的例子：</p>
<blockquote>
<p><code>public class ImmutableValue{</code>  </p>
<p>　　<code>private int value = 0;</code>  </p>
<p>　　<code>public ImmutableValue(int value){</code><br>　　　　<code>this.value = value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public int getValue(){</code><br>　　　　<code>return this.value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public ImmutableValue add(int valueToAdd){</code><br>　　　　<code>return new ImmutableValue(this.value + valueToAdd);</code><br>　　<code>}</code>  </p>
<p><code>}</code>  </p>
</blockquote>
<p>　　注意add()方法返回了一个带有加法操作结果的新ImmutableValue实例，而不是直接对自己的value值进行加法操作。</p>
<h2 id="引用不是线程安全的！">引用不是线程安全的！</h2>
<p>　　<br>　　需要记住的是，即使一个对象是线程安全的不可变对象，这个对象的引用也可能不是线程安全的。看下面的例子：</p>
<blockquote>
<p><code>public void Calculator{</code><br>　　<code>private ImmutableValue currentValue = null;</code>  </p>
<p>　　<code>public ImmutableValue getValue(){</code><br>　　　　<code>return currentValue;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void setValue(ImmutableValue newValue){</code><br>　　　　<code>this.currentValue = newValue;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void add(int newValue){</code><br>　　　　<code>this.currentValue = this.currentValue.add(newValue);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　Calculator类有一个ImmutableValue 实例的引用，注意通过setValue()和add()这两个方法都可能会改变这个引用。所以即使Calculator类在内部使用了不可变的对象，它自己却不是不可变的也就不是线程安全的。换句话说：ImmutableValue类是线程安全的，但是对它的使用却不是，当你尝试使用不可变性来达到线程安全的目标时需要牢记这一点。</p>
<p>　　为了保证Calculator的线程安全你只需要声明getValue(), setValue()和 add()方法为synchronized的即可。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://fantasynew.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="不可变性" scheme="http://fantasynew.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程安全和资源共享]]></title>
    <link href="http://fantasynew.github.io/2014/04/18/06.thread-safety-and-shared-resources/"/>
    <id>http://fantasynew.github.io/2014/04/18/06.thread-safety-and-shared-resources/</id>
    <published>2014-04-18T14:06:44.000Z</published>
    <updated>2014-05-04T14:07:46.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/thread-safety.html</a></p>
<p>　　代码被多个线程同时调用还很安全被称作线程安全的。一段线程安全的代码不会存在竞态条件，竞态条件只存在于多个线程同时更新共享资源的情况下，所以了解java线程运行时都共享哪些资源是非常重要的。</p>
<h2 id="局部变量">局部变量</h2>
<p>　　局部变量保存在每个线程自己的栈中，也就意味着局部变量不会在线程之间共享，同时意味着所有基本类型的局部变量都是线程安全的。下面是一个线程安全的基本类型局部变量的例子：</p>
<blockquote>
<p><code>public void someMethod(){</code><br>　　<code>long threadSafeInt = 0;</code><br>　　<code>threadSafeInt++;</code><br><code>}</code>   </p>
</blockquote>
<h2 id="局部对象引用">局部对象引用</h2>
<p>　　<br>　　局部对象引用有一点不同，引用本身不会共享，但是被引用的对象不是保存在每个线程的局部栈中，所有的对象都保存在共享堆中。如果一个方法创建的局部对象并没有在其他方法被引用，那它是线程安全的。实际上你还可以把它传给另一个方法或者对象只要这些方法和对象不让其他线程获取到传过来的对象即可。下面是一个线程安全的局部对象例子：</p>
<blockquote>
<p><code>public void someMethod(){</code><br>　　<code>LocalObject localObject = new LocalObject();</code><br>　　<code>localObject.callMethod();</code><br>　　<code>method2(localObject);</code><br><code>}</code>  </p>
<p><code>public void method2(LocalObject localObject){</code><br>　　<code>localObject.setValue(&quot;value&quot;);</code><br><code>}</code>  </p>
</blockquote>
<p>　　这个例子中的LocalObject实例没有被返回也没有传递给可以从外部访问someMethod()方法的其他对象。每个执行someMethod()方法的线程都会创建自己的LocalObject实例并分配给localObject引用，所以这里LocalObject用法是线程安全的。实际上someMethod()整个方法都是线程安全。即使LocalObject实例被当作参数传递给同一类或者其他类中的其他方法，它也是线程安全的。但是唯一例外情况是一个把LocalObject 当作参数调用的方法，用允许其他线程访问它的方式保存LocalObject 实例。</p>
<h2 id="对象成员">对象成员</h2>
<p>　　对象成员与对象一起存储在堆里面，所以如果两个线程调用同一对象实例的一个方法并且这个方法修改对象的成员这个方法就不是线程安全的。下面是一个非线程安全的方法示例：</p>
<blockquote>
<p><code>public class NotThreadSafe{</code><br>　　<code>StringBuilder builder = new StringBuilder();</code>    </p>
<p>　　<code>public add(String text){</code><br>　　　　<code>this.builder.append(text);</code><br>　　<code>}</code><br><code>}</code>   </p>
</blockquote>
<p>　　如果两个线程同时调用同一个NotThreadSafe实例的add()方法就会引起竞态条件。比如：</p>
<blockquote>
<p><code>NotThreadSafe sharedInstance = new NotThreadSafe();</code>  </p>
<p><code>new Thread(new MyRunnable(sharedInstance)).start();</code><br><code>new Thread(new MyRunnable(sharedInstance)).start();</code>  </p>
<p><code>public class MyRunnable implements Runnable{</code><br>　　<code>NotThreadSafe instance = null;</code>  </p>
<p>　　<code>public MyRunnable(NotThreadSafe instance){</code><br>　　　　<code>this.instance = instance;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void run(){</code><br>　　　　<code>this.instance.add(&quot;some text&quot;);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意这两个MyRunnable实例共享了同一个NotThreadSafe实例，所以当它们调用NotThreadSafe实例的add()方法时会引起竞态条件。  </p>
<p>　　然而如果两个线程在不同的实例上面同时调用add()方法并不会引起静态条件。下面是稍微修改之后的例子：</p>
<blockquote>
<p><code>new Thread(new MyRunnable(new NotThreadSafe())).start();</code><br><code>new Thread(new MyRunnable(new NotThreadSafe())).start();</code>  </p>
</blockquote>
<p>　　现在这两个线程都有自己的NotThreadSafe实例，所以它们对add方法的调用并不会妨碍对方，这段代码没有竞态条件。所以即使一个对象不是线程安全的，仍可以找到一个方式来消除竞态条件。　</p>
<h2 id="线程控制逃逸规则">线程控制逃逸规则</h2>
<p>　　当需要判断你的代码访问某些资源是否是线程安全的时候你可以用线程控制逃逸规则：</p>
<blockquote>
<p><code>如果一个资源在一个线程的控制下被创建、使用和销毁并且永远不会逃脱线程的控制，则该资源的使用是线程安全的。</code>  </p>
</blockquote>
<p>　　资源可以是任何共享资源像对象、数组、文件、数据库连接、socket等等。java语言中不需要你明确的销毁对象，所以“被销毁”意味着对象的引用丢失了或者被置为null。  </p>
<p>　　即使对象的使用是线程安全的，如果这个对象包含共享资源（比如文件或者数据库连接）你的整个应用程序也不会是线程安全的。比如，如果线程1和线程2都创建了自己的数据库连接，连接1和连接2，每个连接自己本身的使用是线程安全的。但是这两个数据库连接指向的数据库使用时可能不是线程安全的。比如如果两个线程执行如下代码：
　　</p>
<blockquote>
<p><code>校验记录X是否存在，如果不存在插入一个记录X。</code>  </p>
</blockquote>
<p>　　如果两个线程同时执行这个代码，而且它们校验的记录X碰巧是同一个记录，就会存在这两个线程最终都插入记录X的风险。比如：
　　
　　</p>
<blockquote>
<p><code>线程1检查记录X是否存在，结果是否。</code><br><code>线程2检查记录X是否存在，结果是否。</code><br><code>线程1插入记录X。</code><br><code>线程2插入记录X。</code>  </p>
</blockquote>
<p>　　同样的问题也会发生在操作文件或者其它共享资源的线程上面。因此，区分一个线程控制的是资源本身，还是仅仅是资源的引用非常重要。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://fantasynew.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="资源共享" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[竞态条件与临界区]]></title>
    <link href="http://fantasynew.github.io/2014/04/15/05.race-conditions-and-critical-sections/"/>
    <id>http://fantasynew.github.io/2014/04/15/05.race-conditions-and-critical-sections/</id>
    <published>2014-04-15T14:06:44.000Z</published>
    <updated>2014-04-26T10:43:13.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html</a></p>
<p>　　在一个应用程序中同时运行多个线程本身不会引起问题，问题出现在多个线程访问相同资源的时候，比如同一内存（变量，数组或者对象），系统（数据库，网络服务等等）或者文件。事实上，问题只出现在一个或者多个线程对这些资源进行写操作的时候。只要这些资源没有变化，多个线程对同一资源进行读操作是安全的。</p>
<p>　　下面是被多个线程同时执行时可能会失败的代码示例：
　　</p>
<blockquote>
<p><code>public class Counter {</code><br>　　<code>protected long count = 0;</code><br>　　<code>public void add(long value){</code><br>　　　　<code>this.count = this.count + value;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　想象如果两个线程A和B在同一个Counter实例中执行这个add方法，我们无法知道操作系统什么时候在这两个线程之间进行切换。java虚拟机不会把这段代码作为单指令执行，而是按照下面的顺序执行：</p>
<blockquote>
<p><code>把this.count从内存中读取到寄存器</code><br><code>将寄存器中的值加1</code><br><code>把寄存器中的值写到内存中</code>  </p>
</blockquote>
<p>　　观察如果线程A和B混合执行会发生什么：</p>
<blockquote>
<p><code>this.count = 0;</code><br><code>A: 把this.count从内存中读取到寄存器(0)</code><br><code>B: 把this.count从内存中读取到寄存器(0)</code><br><code>B: 将寄存器中的值加2</code><br><code>B：把寄存器中的值2写到内存中，this.count的值是2</code><br><code>A：将寄存器中的值加3</code><br><code>A：把寄存器中的值3写到内存中，this.count的值是3</code>  </p>
</blockquote>
<p>　　这两个线程把数值2和3加到了counter上面，所以两个线程混合执行完成之后预期值应该是5。然而，由于两个线程的执行是交错的，这两个线程从内存中读取的都是0，接着它们分别加它们自己的值2和3并写回到内存中。取代5留在this.count的值会是最后一个线程写入的值。在上面的例子中是线程A，但是也可能是线程B，没有适当的线程同步机制我们没办法知道线程是如何交错执行的。</p>
<h2 id="竞态条件与临界区">竞态条件与临界区</h2>
<p>　　在两个线程竞争同一资源的情况下，资源访问的顺序非常重要的，被称作存在竞态条件。导致竞态条件出现的代码区域被称作临界区。在前一个例子中方法add()就是一个临界区，它导致了竞态条件。临界区里适当的线程同步可以避免竞态条件的发生。　</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="竞态条件" scheme="http://fantasynew.github.io/tags/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/"/>
    
      <category term="临界区" scheme="http://fantasynew.github.io/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建和启动java线程]]></title>
    <link href="http://fantasynew.github.io/2014/04/13/04.creating-and-starting-threads/"/>
    <id>http://fantasynew.github.io/2014/04/13/04.creating-and-starting-threads/</id>
    <published>2014-04-13T14:06:44.000Z</published>
    <updated>2014-04-26T10:42:49.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html</a></p>
<p>　　java线程对象与其他java对象一样，所有的线程都继承java.lang.Thread类，或者java.lang.Thread的子类。除了作为对象，java线程还可以执行代码。</p>
<h2 id="创建启动线程">创建启动线程</h2>
<p>　　在java中可以用如下方式创建一个线程：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread();</code>　　</p>
</blockquote>
<p>　　可以通过调用它的start()方法来启动这个线程，像这样：
　　</p>
<blockquote>
<p><code>thread.start();</code>　　</p>
</blockquote>
<p>　　这个例子并没有指定线程执行任何代码，调用完成之后它就会停止。  </p>
<p>　　有两种方式来指定线程执行代码。第一种是创建一个Thread 子类并且重写它的run()方法，第二种创建类时实现Runnable接口，下面会介绍这两种方法。</p>
<h2 id="Thread子类">Thread子类</h2>
<p>　　第一种指定线程执行代码的方式是创建一个Thread子类并重写它的run()方法,run()方法就是你的线程调用start()后执行的方法。例子如下：  </p>
<blockquote>
<p><code>public class MyThread extends Thread {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;MyThread running&quot;);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　你可以这样创建和启动上面的线程：</p>
<blockquote>
<p><code>MyThread myThread = new MyThread();</code><br><code>myTread.start();</code></p>
</blockquote>
<p>　　start()请求会在线程开始之后立刻返回，它不会等待run()方法执行完，run()方法就好像被另一个CPU执行一样。当run()方法执行时它会打印出文本“MyThread running”。</p>
<p>　　你还可以按照下面的方法创建一个Thread的匿名子类：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(){</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;Thread Running&quot;);</code><br>　　<code>}</code><br><code>}</code><br><code>thread.start();</code> </p>
</blockquote>
<p>　　一旦run()方法被这个新线程执行的时候这个例子就会打印出“Thread running”。</p>
<h2 id="实现Runnable接口">实现Runnable接口</h2>
<p>　　第二种指定线程执行代码的方式是创建一个实现了java.lang.Runnable接口的类。Runnable对象会被一个线程执行。  </p>
<p>　　下面是java实现Runnable接口的例子：
　　</p>
<blockquote>
<p><code>public class MyRunnable implements Runnable {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;MyRunnable running&quot;);</code><br>　　<code>}</code><br><code>}</code>  　</p>
</blockquote>
<p>　　为了让run()方法被一个线程执行，需要把MyRunnable的实例对象传到Thread类的构造函数中。例子如下：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(new MyRunnable());</code><br><code>myTread.start();</code></p>
</blockquote>
<p>　　这个线程开始时他会调用MyRunnable实例对象的run()方法而不是执行它自己的run()方法。上例会打印出“MyRunnable running”。</p>
<p>　　同样，你也可以这样创建一个实现Runnable接口的匿名类：
　　</p>
<blockquote>
<p><code>Runnable myRunnable = new Runnable(){</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;Runnable running&quot;);</code><br>　　<code>}</code><br><code>}</code><br><code>Thread thread = new Thread(myRunnable);</code><br><code>thread.start();</code>　　</p>
</blockquote>
<h2 id="选择创建子类还是实现Runnable接口">选择创建子类还是实现Runnable接口</h2>
<p>　　这两种方式哪个好没有明确的答案，两种方式都能正常工作。就我个人而言，我喜欢实现Runnable接口，然后把它交给一个线程实例处理。因为实现Runnable接口的线程在线程池中很容易管理，当线程池中的线程有空闲时线程池很容易排列Runnable实例。这对于子类Thread 有一点点困难。</p>
<p>　　有时候你可能需要同时实现Runnable接口并且创建Thread子类。比如，创建一个Thread 子类运行多个实现Runnable接口的类，这常被用来实现一个线程池。
　　</p>
<h2 id="常见错误：调用run()方法而不是start()方法">常见错误：调用run()方法而不是start()方法</h2>
<p>　　当创建和启动一个线程时常犯的错误是直接调用Thread的run()方法而不是start()方法，像这样：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(new MyRunnable());</code><br><code>thread.run();  //should be start();</code></p>
</blockquote>
<p>　　起初你可能不会注意到任何异常因为run()方法按照你所期望的那样被执行了。然而它不是被你刚刚创建的新线程执行的，run()方法反而是被创建新线程的线程所执行的。换句话说，是被执行了上面两行代码的线程执行的。为了让新创建的线程执行MyRunnable 实例的run()方法，你必须调用新线程的start()方法。
　　</p>
<h2 id="线程名">线程名</h2>
<p>　　创建一个线程时你可以给它一个名称，线程名可以帮助你区别其它的线程。比如，如果多个线程都用System.out输出信息，可以很方便查出是哪个线程输出的信息。例子如下：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(&quot;New Thread&quot;) {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;run by: &quot; + getname());</code><br>　　<code>}</code><br><code>}</code><br><code>thread.start();</code><br><code>System.out.println(thread.getName());</code>  </p>
</blockquote>
<p>　　注意字符串”New Thread”作为参数传给线程的构造函数，这个字符串就是线程名。这个线程名可以通过线程的getName()方法获得。使用实现Runnable 接口方式时你也可以给线程传递一个名称。例子如下：
　　</p>
<blockquote>
<p><code>MyRunnable runnable = new MyRunnable();</code><br><code>Thread thread = new Thread(runnable, &quot;New Thread&quot;);</code><br><code>thread.start();</code><br><code>System.out.println(thread.getName());</code> 　　</p>
</blockquote>
<p>　　不过请注意，既然MyRunnable类不是Thread的子类，它没有使用执行它的线程的getName()方法的权限。当前正在执行的线程引用可以使用下面的方式获得</p>
<blockquote>
<p><code>Thread.currentThread();</code>  </p>
</blockquote>
<p>　　获取当前正在执行线程名称的代码可以这样写：</p>
<blockquote>
<p><code>String threadName = Thread.currentThread().getName();</code></p>
</blockquote>
<h2 id="java线程实例">java线程实例</h2>
<p>　　这里有一个小例子。首先它打印出执行main()方法的线程的名称，这个线程是被JVM分配的。接着它开始10个线程并给它们一个数字作为线程名，每个线程都会打印出它们的名称并结束执行。</p>
<blockquote>
<p><code>public class ThreadExample {</code><br>　　<code>public static void main(String[] args){</code><br>　　　　<code>System.out.println(Thread.currentThread().getName());</code><br>　　　　<code>for(int i=0; i&lt;10; i++){</code><br>　　　　　　<code>new Thread(&quot;&quot; + i){</code><br>　　　　　　　　<code>public void run(){</code><br>　　　　　　　　　　<code>System.out.println(&quot;Thread: &quot; + getName() + &quot; running&quot;);</code><br>　　　　　　　　<code>}</code><br>　　　　　　<code>}.start();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code></p>
</blockquote>
<p>　　注意虽然这些线程是按照一定顺序(1、2、3…)启动的，它们可不会按照该顺序执行，也就是线程1可能不会作为第一个把自己名称输出到System.out的线程。因为这些线程原则上是并行执行的而不是顺序执行，JVM和/或操作系统决定线程的执行顺序，打印的顺序和开始的顺序并不一定是一致的。　</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Thread类" scheme="http://fantasynew.github.io/tags/Thread%E7%B1%BB/"/>
    
      <category term="Runnable接口" scheme="http://fantasynew.github.io/tags/Runnable%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程的代价]]></title>
    <link href="http://fantasynew.github.io/2014/04/11/03.costs-of-multithreading/"/>
    <id>http://fantasynew.github.io/2014/04/11/03.costs-of-multithreading/</id>
    <published>2014-04-11T14:06:44.000Z</published>
    <updated>2014-04-26T10:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/costs.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/costs.html</a></p>
<h2 id="简介">简介</h2>
<p>　　从单线程应用程序更新到多线程可不光带来优点，它也会付出一些代价。千万不要仅仅因为你可以使用多线程就给应用程序添加多线程。你应该明确的知道使用多线程带来的好处比所付出的代价多的时候才可以使用多线程。有疑问时，试着衡量应用程序的性能和响应时间，不要只是简单的猜想。</p>
<h2 id="更复杂的设计">更复杂的设计</h2>
<p>　　尽管多线程应用程序的某些部分比单线程应用程序简单，但是其他部分更为复杂。被多个线程执行的代码在访问共享数据的时候需要特别注意。线程交互可不总是那么简单，不正确的线程同步引起的错误可能更难测试、复现和修改。</p>
<h2 id="上下文切换的开销">上下文切换的开销</h2>
<p>　　当CPU从一个线程的执行切换到另一个时，CPU需要保存当前线程的本地数据，程序指针等，并且加载下一个线程的本地数据，程序指针来继续执行，这个切换被称作“上下文切换”。CPU从一个线程的上下文的执行切换到另一个线程的上下文中。  </p>
<p>　　上下文切换并不廉价，如果没有必要应该减少线程之间的上下文切换。</p>
<p>　　可以在维基上面看到更多关于上下文切换的信息：
　　</p>
<blockquote>
<p><a href="http://en.wikipedia.org/wiki/Context_switch" target="_blank">http://en.wikipedia.org/wiki/Context_switch</a></p>
</blockquote>
<h2 id="增加资源消耗">增加资源消耗</h2>
<p>　　一个线程需要从计算机中获得一些资源来保证运行。除了CPU时间段线程还需要一些内存来保存它的本地堆栈，还需要一些操作系统中的资源来管理线程。试着创建一个程序，让它创建100个线程，这些线程什么都不做只是等待的，然后看看当这个应用程序运行时有多少内存被占用。  </p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="资源消耗" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
    
      <category term="上下文切换" scheme="http://fantasynew.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程的优点]]></title>
    <link href="http://fantasynew.github.io/2014/04/09/02.multithreading-benefits/"/>
    <id>http://fantasynew.github.io/2014/04/09/02.multithreading-benefits/</id>
    <published>2014-04-09T14:06:44.000Z</published>
    <updated>2014-04-26T10:42:24.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/benefits.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/benefits.html</a></p>
<h2 id="简介">简介</h2>
<p>　　尽管有许多挑战，多线程仍然被使用的原因是它有几个优点，这些优点是：</p>
<blockquote>
<ul>
<li>更好的资源利用率。 </li>
<li>在某些情况下程序设计的更简单。</li>
<li>程序响应很快。</li>
</ul>
</blockquote>
<h2 id="更好的资源利用率">更好的资源利用率</h2>
<p>　　想象一个从本地文件系统中读取和处理文件的应用程序。假设从硬盘读取一个文件需要5秒，处理它需要2秒。处理两个文件则需要:</p>
<blockquote>
<p>　　<code>5秒读取文件A</code><br>　　<code>2秒处理文件A</code><br>　　<code>5秒读取文件B</code><br>　　<code>2秒处理文件B</code>  </p>
<hr>
<p>　　<code>总共14秒</code></p>
</blockquote>
<p>　　当从硬盘中读取文件时，大部分的CPU时间花费在等待硬盘读取数据上面了。这段时间里CPU处于绝对空闲状态，它可以做一些其他事情。通过改变操作的顺序，CPU可以得到更有效地利用。看下面的顺序：
　　</p>
<blockquote>
<p>　　<code>5秒读取文件A</code><br>　　<code>5秒钟读取文件B + 2秒钟处理文件A</code><br>　　<code>2秒处理文件B</code>  </p>
<hr>
<p>　　<code>总共12秒</code>  </p>
</blockquote>
<p>　　CPU等待第一个文件的读取，接着开始读取第二个文件，当读取第二个文件的过程中CPU处理第一个文件。记住，在等待磁盘读取文件的时候CPU处于绝对空闲状态。</p>
<p>　　一般而言，CPU可以在等待IO的过程中做其他事情。不必非得磁盘的IO，还可以是网络IO，或者是用户的输入。网络和硬盘的IO通常都比CPU和内存的IO慢很多。　　</p>
<h2 id="更简单的程序设计">更简单的程序设计</h2>
<p>　　在单线程应用程序中如果你想编程实现上面提到的读取和处理功能，你必须跟踪每个文件的读取和处理状态。相反，你可以启动两个线程，每个线程负责一个文件的读取和处理。每个线程在等待硬盘读取它所需要的文件过程中都会堵塞，等待过程中其他线程可以使用CPU来处理他们已经读取过来的文件。导致的结果是硬盘一直处在忙碌状态，不断的读取不同的文件到内存中，这样就使硬盘和CPU都得到了有效利用。这也很好设计，因为每个线程只需要跟踪一个文件。  
　　</p>
<h2 id="程序响应更快">程序响应更快</h2>
<p>　　把单线程应用程序替换成多线程应用程序的另一个常见原因是想获得响应更快的应用程序。想象一个服务器应用在一些端口监听传入的请求。当一个请求到达后，它处理这个请求然后回去继续监听。这个服务器的循环流程概述如下：</p>
<blockquote>
<p><code>while(server is active){</code><br>　　<code>listen for request</code><br>　　<code>hand request to worker thread</code><br><code>}</code>  </p>
</blockquote>
<p>　　如果一个请求需要花费很长的时间来处理，在这段时间内新的客户端就无法发送请求给服务器。只有在服务器监听的时候请求才能被接收到。  </p>
<p>　　另一个设计方法是监听线程把请求传递给响应线程，然后立刻返回到监听状态。响应线程负责处理请求并给客户端发送一个回复。这个设计概述如下：  </p>
<blockquote>
<p><code>while(server is active){</code><br>　　<code>listen for request</code><br>　　<code>hand request to worker thread</code><br><code>}</code>  </p>
</blockquote>
<p>　　这个方式下，服务器线程可以很快回到监听状态，因此更多的客户端可以发送请求到服务器，这个服务也变得响应更快。  </p>
<p>　　桌面应用程序同样如此，如果你点击一个按钮就开启一个耗时的任务，并且执行这个任务的线程同时负责刷新窗口和按钮，那么在这个任务执行过程中这个应用程序会显示无响应的。相反，这个任务可以交给一个响应线程来处理，当响应线程在处理这个任务的时候，窗口线程可以自由响应其他的用户请求。当响应线程结束的时候它会通知窗口线程，窗口线程就会根据任务的结果来更新应用程序窗口。用户的角度看这种具有响应线程的程序会显得响应速度很快。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="资源利用率" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发介绍]]></title>
    <link href="http://fantasynew.github.io/2014/04/07/01.introduction-to-java-concurrency/"/>
    <id>http://fantasynew.github.io/2014/04/07/01.introduction-to-java-concurrency/</id>
    <published>2014-04-07T14:06:44.000Z</published>
    <updated>2014-05-15T14:22:19.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<h2 id="引子">引子</h2>
<p>　　过去一台计算机只有单个CPU，每次只能执行一个程序。后来的计算机可以支持多任务处理，意味着它们可以同时执行多个程序（即任务或流程）。虽然不是真正意义上的“同时”，而是多个程序共享一个CPU，并交给操作系统在执行中的程序间进行切换，以保证每个程序在切换过程中都能得到一定的执行时间。  <a id="more"></a></p>
<p>　　多任务处理技术给软件开发人员带来了新的挑战。程序不能被假设占用所有的CPU可用时间、所有的内存和其它资源。一个“表现良好”的程序应该在不用这些资源的时候对其释放，以保证其它程序的使用。  </p>
<p>　　再后来出现了多线程技术，使得你可以在一个程序内部并行执行多个线程。一个线程的执行可以被认为是一个CPU在执行该程序。当你在一个程序内部执行多个线程时，就好像有多个CPU在同时执行该程序。  </p>
<p>　　多线程比多任务处理更具挑战性，这些线程运行在一个程序里因此会对相同的内存块进行并发读写操作，这可能导致一些在单线程程序里没出现过的错误。这些错误之所以没出现在单CPU的机器中是因为两个线程永远都不会真正意义上“并发”执行。但是伴随着现代多核CPU计算机的出现，也就意味着不同线程可以在不同CPU内核中得到真正意义上的并行执行。  </p>
<p>　　如果一个线程对一个内存块进行读取的时候，另一个线程对它进行写操作，进行第一个线程读出的值应该是哪个？写操作之前的旧值？第二个线程写入的新值？还是这两个值之间的混合值？如果两个线程同时对同一内存块进行写操作，当它们写操作完成之后内存块里的值应该是哪个？第一个线程写入的值？第二个线程写入的值？还是这两个值之间的混合值？没有适当的防护措施任何输出结果都是可能的，这种行为甚至都不可预测，输出结果可以随时改变。  </p>
<h2 id="Java的多线程和并发">Java的多线程和并发</h2>
<p>　　Java是最先支持多线程开发的编程语言之一，java一开始就提供了多线程开发的功能。因此，java开发者们经常会碰到上面提到的那些问题。这就是我写这篇java并发系列的原因，作为自己的笔记，希望其它java开发人员都可从中受益。  </p>
<p>　　这个博客系列主要是关心java的多线程开发，但是多线程中出现的一些问题与多任务处理和分布式系统中出现的问题存在类似，因此这个博客系列会将多任务处理和分布式系统作为参考，所以叫法上称为“并发性”而不是“多线程”。  </p>
<p>　　这个博客系列仍在继续更新中，只要有时间写我就会把新文章更新出来。下表是已经更新的文章：
　　</p>
<h3 id="Java并发">Java并发</h3>
<ul>
<li><a href="http://fantasynew.github.io/2014/04/07/01.introduction-to-java-concurrency/">java并发介绍</a></li>
<li><a href="http://fantasynew.github.io/2014/04/09/02.multithreading-benefits/">多线程的优点</a></li>
<li><a href="http://fantasynew.github.io/2014/04/11/03.costs-of-multithreading/">多线程的代价</a></li>
<li><a href="http://fantasynew.github.io/2014/04/13/04.creating-and-starting-threads/">创建和启动java线程</a></li>
<li><a href="http://fantasynew.github.io/2014/04/15/05.race-conditions-and-critical-sections/">竞态条件与临界区</a></li>
<li><a href="http://fantasynew.github.io/2014/04/18/06.thread-safety-and-shared-resources/">线程安全和资源共享</a></li>
<li><a href="http://fantasynew.github.io/2014/04/21/07.thread-safety-and-immutability/">线程安全和不可变性</a></li>
<li><a href="http://fantasynew.github.io/2014/04/25/08.java-synchronized-blocks/">Java同步块</a></li>
<li><a href="http://fantasynew.github.io/2014/04/29/09.thread-signaling/">线程通信</a></li>
<li><a href="http://fantasynew.github.io/2014/05/01/10.deadlock/">死锁</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<h2 id="引子">引子</h2>
<p>　　过去一台计算机只有单个CPU，每次只能执行一个程序。后来的计算机可以支持多任务处理，意味着它们可以同时执行多个程序（即任务或流程）。虽然不是真正意义上的“同时”，而是多个程序共享一个CPU，并交给操作系统在执行中的程序间进行切换，以保证每个程序在切换过程中都能得到一定的执行时间。  ]]></summary>
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://fantasynew.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://fantasynew.github.io/2014/04/01/hello-world/"/>
    <id>http://fantasynew.github.io/2014/04/01/hello-world/</id>
    <published>2014-04-01T14:06:44.000Z</published>
    <updated>2014-04-22T13:40:13.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io" target="_blank">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs" target="_blank">documentation</a> to learn how to use.</p>
]]></content>
    
    
      <category term="杂乱" scheme="http://fantasynew.github.io/categories/%E6%9D%82%E4%B9%B1/"/>
    
  </entry>
  
</feed>
